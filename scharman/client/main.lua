-- â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—
-- â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘
-- â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘
-- â•šâ•â•â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘
-- â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘
-- â•šâ•â•â•â•â•â•â• â•šâ•â•â•â•â•â•â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â•â•šâ•â•     â•šâ•â•â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â•â•â•
-- CLIENT - MODE COURSE POURSUITE V4.0.1 - FIX SYNCHRONISATION
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- VARIABLES LOCALES
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local inGame = false
local currentVehicle = nil
local instanceId = nil
local currentBucket = 0
local myRole = nil
local opponentId = nil

-- Threads
local blockExitThread = nil
local blockExitTimerThread = nil
local vehicleExitThread = nil
local damageZoneThread = nil
local warZoneThread = nil
local warningMessageActive = false
local zoneWaitingThread = nil
local vehicleShootBlockThread = nil
local deathInVehicleThread = nil

-- âœ… NOUVEAU V4.0: Threads pour les timers
local chasseurTimerThread = nil
local cibleTimerThread = nil

-- Timers
local gameEndTime = nil
local gameStartTime = nil

-- âœ… NOUVEAU V4.0: Timers spÃ©cifiques
local chasseurZoneTimeLeft = 0
local cibleZoneTimeLeft = 0
local chasseurTimerActive = false
local cibleTimerActive = false

-- Zone de guerre
local canExitVehicle = false
local warZoneActive = false
local warZonePosition = nil
local warZoneBlip = nil
local warZoneCenterBlip = nil
local warZoneRadius = Config.CoursePoursuit.WarZoneRadius

-- Ã‰tats
local iAmChasseur = false
local iAmCible = false
local zoneCreatedByMe = false
local zoneCreatedByOpponent = false
local iAmInZone = false

-- âœ… NOUVEAU V4.0.1: Ã‰tat de synchronisation
local isReadyForStart = false

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- FONCTIONS UTILITAIRES
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function ShowGameNotification(message, duration, notifType)
    SendNUIMessage({
        action = 'showNotification',
        data = {
            message = message,
            duration = duration or Config.CoursePoursuit.MessageDuration,
            type = notifType or 'info'
        }
    })
end

local function ForcePlayerIntoVehicle(ped, vehicle, seat)
    if not ped or not DoesEntityExist(ped) then
        Config.ErrorPrint('PED invalide!')
        return false
    end
    
    if not vehicle or not DoesEntityExist(vehicle) then
        Config.ErrorPrint('VÃ©hicule invalide!')
        return false
    end
    
    Config.DebugPrint('Placement joueur dans vÃ©hicule...')
    
    SetVehicleOnGroundProperly(vehicle)
    Wait(100)
    
    TaskWarpPedIntoVehicle(ped, vehicle, seat)
    Wait(500)
    
    local attempts = 0
    local maxAttempts = 10
    
    while GetVehiclePedIsIn(ped, false) ~= vehicle and attempts < maxAttempts do
        attempts = attempts + 1
        Config.DebugPrint('Tentative ' .. attempts .. '/' .. maxAttempts)
        
        TaskWarpPedIntoVehicle(ped, vehicle, seat)
        Wait(300)
        
        if GetVehiclePedIsIn(ped, false) ~= vehicle then
            SetPedIntoVehicle(ped, vehicle, seat)
            Wait(300)
        end
    end
    
    local isInVehicle = GetVehiclePedIsIn(ped, false) == vehicle
    
    if isInVehicle then
        Config.SuccessPrint('Joueur placÃ© dans vÃ©hicule!')
        return true
    else
        Config.ErrorPrint('Ã‰CHEC placement aprÃ¨s ' .. attempts .. ' tentatives')
        return false
    end
end

local function ResurrectPlayerWithAnimation(ped, coords)
    Config.InfoPrint('[REVIVE] RÃ©animation du joueur avec animation...')
    
    SetEntityCoords(ped, coords.x, coords.y, coords.z, false, false, false, true)
    SetEntityHeading(ped, coords.w)
    
    NetworkResurrectLocalPlayer(coords.x, coords.y, coords.z, coords.w, true, false)
    Wait(500)
    
    local attempts = 0
    while GetEntityHealth(ped) <= 0 and attempts < 3 do
        NetworkResurrectLocalPlayer(coords.x, coords.y, coords.z, coords.w, true, false)
        Wait(500)
        attempts = attempts + 1
    end
    
    SetEntityHealth(ped, 200)
    SetPlayerHealthRechargeMultiplier(PlayerId(), 0.0)
    
    RequestAnimDict("get_up@directional@movement@from_knees@action")
    while not HasAnimDictLoaded("get_up@directional@movement@from_knees@action") do
        Wait(10)
    end
    
    TaskPlayAnim(ped, "get_up@directional@movement@from_knees@action", "getup_l_0", 8.0, -8.0, 1000, 0, 0, false, false, false)
    Wait(1000)
    
    ClearPedTasksImmediately(ped)
    
    Config.SuccessPrint('[REVIVE] RÃ©animation complÃ¨te!')
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- âœ… NOUVEAU V4.0: GESTION TIMERS CHASSEUR
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function StartChasseurTimer()
    if chasseurTimerThread or not iAmChasseur then return end
    
    Config.InfoPrint('[TIMER CHASSEUR] ğŸ”« DÃ©marrage timer zone (60s)')
    
    chasseurZoneTimeLeft = Config.CoursePoursuit.ChasseurZoneTimer
    chasseurTimerActive = true
    
    -- Afficher le timer
    SendNUIMessage({
        action = 'showTimer',
        data = {
            role = 'chasseur',
            duration = chasseurZoneTimeLeft,
            message = 'CrÃ©ez la zone de guerre !'
        }
    })
    
    chasseurTimerThread = CreateThread(function()
        while chasseurTimerActive and chasseurZoneTimeLeft > 0 and not zoneCreatedByMe do
            Wait(1000)
            chasseurZoneTimeLeft = chasseurZoneTimeLeft - 1
            
            -- Mettre Ã  jour le timer UI
            SendNUIMessage({
                action = 'updateTimer',
                data = {
                    timeLeft = chasseurZoneTimeLeft
                }
            })
            
            -- Avertissements
            if chasseurZoneTimeLeft == 30 then
                ShowGameNotification(string.format(Config.CoursePoursuit.Notifications.chasseurTimerWarning, 30), 3000, 'warning')
            elseif chasseurZoneTimeLeft == 10 then
                ShowGameNotification(string.format(Config.CoursePoursuit.Notifications.chasseurTimerWarning, 10), 3000, 'error')
            end
        end
        
        -- VÃ©rifier si timeout
        if chasseurTimerActive and chasseurZoneTimeLeft <= 0 and not zoneCreatedByMe then
            Config.ErrorPrint('[TIMER CHASSEUR] â±ï¸ TIMEOUT! Zone non crÃ©Ã©e')
            ShowGameNotification(Config.CoursePoursuit.Notifications.chasseurTimeout, 5000, 'error')
            
            -- Masquer le timer
            SendNUIMessage({ action = 'hideTimer' })
            
            -- Signaler au serveur
            TriggerServerEvent('scharman:server:chasseurTimeout', instanceId)
        else
            -- Zone crÃ©Ã©e Ã  temps
            SendNUIMessage({ action = 'hideTimer' })
        end
        
        chasseurTimerThread = nil
        chasseurTimerActive = false
    end)
end

local function StopChasseurTimer()
    if chasseurTimerThread then
        chasseurTimerActive = false
        chasseurTimerThread = nil
        SendNUIMessage({ action = 'hideTimer' })
        Config.InfoPrint('[TIMER CHASSEUR] â¹ï¸ Timer arrÃªtÃ©')
    end
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- âœ… NOUVEAU V4.0: GESTION TIMERS CIBLE
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function StartCibleTimer()
    if cibleTimerThread or not iAmCible then return end
    
    Config.InfoPrint('[TIMER CIBLE] ğŸ¯ DÃ©marrage timer zone (60s)')
    
    cibleZoneTimeLeft = Config.CoursePoursuit.CibleZoneTimer
    cibleTimerActive = true
    
    -- Afficher le timer
    SendNUIMessage({
        action = 'showTimer',
        data = {
            role = 'cible',
            duration = cibleZoneTimeLeft,
            message = 'Rejoignez la zone de guerre !'
        }
    })
    
    cibleTimerThread = CreateThread(function()
        while cibleTimerActive and cibleZoneTimeLeft > 0 and not iAmInZone do
            Wait(1000)
            cibleZoneTimeLeft = cibleZoneTimeLeft - 1
            
            -- Mettre Ã  jour le timer UI
            SendNUIMessage({
                action = 'updateTimer',
                data = {
                    timeLeft = cibleZoneTimeLeft
                }
            })
            
            -- Avertissements
            if cibleZoneTimeLeft == 30 then
                ShowGameNotification(string.format(Config.CoursePoursuit.Notifications.cibleTimerWarning, 30), 3000, 'warning')
            elseif cibleZoneTimeLeft == 10 then
                ShowGameNotification(string.format(Config.CoursePoursuit.Notifications.cibleTimerWarning, 10), 3000, 'error')
            end
        end
        
        -- VÃ©rifier si timeout
        if cibleTimerActive and cibleZoneTimeLeft <= 0 and not iAmInZone then
            Config.ErrorPrint('[TIMER CIBLE] â±ï¸ TIMEOUT! Zone non rejointe')
            ShowGameNotification(Config.CoursePoursuit.Notifications.cibleTimeout, 5000, 'error')
            
            -- Masquer le timer
            SendNUIMessage({ action = 'hideTimer' })
            
            -- Signaler au serveur
            TriggerServerEvent('scharman:server:cibleTimeout', instanceId)
        else
            -- Zone rejointe Ã  temps
            SendNUIMessage({ action = 'hideTimer' })
        end
        
        cibleTimerThread = nil
        cibleTimerActive = false
    end)
end

local function StopCibleTimer()
    if cibleTimerThread then
        cibleTimerActive = false
        cibleTimerThread = nil
        SendNUIMessage({ action = 'hideTimer' })
        Config.InfoPrint('[TIMER CIBLE] â¹ï¸ Timer arrÃªtÃ©')
    end
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ZONE DE GUERRE
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function CreateWarZoneVisuals(position)
    if not position then
        Config.ErrorPrint('[ZONE] Position invalide')
        return false
    end
    
    if warZoneBlip then
        RemoveBlip(warZoneBlip)
    end
    
    warZoneBlip = AddBlipForRadius(position.x, position.y, position.z, warZoneRadius)
    SetBlipHighDetail(warZoneBlip, true)
    SetBlipColour(warZoneBlip, Config.CoursePoursuit.WarZoneBlipColor)
    SetBlipAlpha(warZoneBlip, 180)
    
    if warZoneCenterBlip then
        RemoveBlip(warZoneCenterBlip)
    end
    
    warZoneCenterBlip = AddBlipForCoord(position.x, position.y, position.z)
    SetBlipSprite(warZoneCenterBlip, Config.CoursePoursuit.WarZoneBlipSprite)
    SetBlipDisplay(warZoneCenterBlip, 4)
    SetBlipScale(warZoneCenterBlip, 1.2)
    SetBlipColour(warZoneCenterBlip, Config.CoursePoursuit.WarZoneBlipColor)
    SetBlipAsShortRange(warZoneCenterBlip, false)
    BeginTextCommandSetBlipName("STRING")
    AddTextComponentString("ğŸ”´ ZONE DE GUERRE")
    EndTextCommandSetBlipName(warZoneCenterBlip)
    
    Config.SuccessPrint('Visuels zone de guerre crÃ©Ã©s')
    return true
end

local function StartWarZoneThread()
    if warZoneThread then return end
    
    Config.InfoPrint('Thread rendu zone dÃ©marrÃ©')
    
    warZoneThread = CreateThread(function()
        while inGame and warZoneActive do
            Wait(0)
            
            if not warZonePosition then
                Wait(100)
                goto continue
            end
            
            local pos = warZonePosition
            
            DrawMarker(
                28,
                pos.x, pos.y, pos.z,
                0.0, 0.0, 0.0,
                0.0, 0.0, 0.0,
                warZoneRadius, warZoneRadius, Config.CoursePoursuit.WarZoneLightHeight,
                Config.CoursePoursuit.WarZoneColor.r,
                Config.CoursePoursuit.WarZoneColor.g,
                Config.CoursePoursuit.WarZoneColor.b,
                Config.CoursePoursuit.WarZoneColor.a,
                false, false, 2, false, nil, nil, false
            )
            
            DrawMarker(
                1,
                pos.x, pos.y, pos.z - 1.0,
                0.0, 0.0, 0.0,
                0.0, 0.0, 0.0,
                warZoneRadius * 2, warZoneRadius * 2, 1.0,
                Config.CoursePoursuit.WarZoneColor.r,
                Config.CoursePoursuit.WarZoneColor.g,
                Config.CoursePoursuit.WarZoneColor.b,
                150,
                false, false, 2, false, nil, nil, false
            )
            
            ::continue::
        end
        
        warZoneThread = nil
        Config.DebugPrint('Thread rendu zone arrÃªtÃ©')
    end)
end

local function CreateWarZone(position)
    Config.InfoPrint('ğŸ”´ CRÃ‰ATION ZONE DE GUERRE')
    Config.DebugPrint('[ZONE] Position: ' .. tostring(position))
    
    warZonePosition = position
    warZoneActive = true
    zoneCreatedByMe = true
    
    -- âœ… V4.0: ArrÃªter le timer chasseur
    StopChasseurTimer()
    
    if not CreateWarZoneVisuals(position) then
        Config.ErrorPrint('Ã‰chec crÃ©ation visuels zone')
        return false
    end
    
    StartWarZoneThread()
    
    TriggerServerEvent('scharman:server:zoneCreated', instanceId, position)
    
    ShowGameNotification(Config.CoursePoursuit.Notifications.warZoneCreated, 5000, 'warning')
    
    Config.SuccessPrint('Zone crÃ©Ã©e Ã : ' .. tostring(position))
    return true
end

local function DeleteWarZone()
    Config.DebugPrint('Suppression zone de guerre...')
    
    warZoneActive = false
    warZonePosition = nil
    zoneCreatedByMe = false
    zoneCreatedByOpponent = false
    iAmInZone = false
    
    if warZoneBlip then
        RemoveBlip(warZoneBlip)
        warZoneBlip = nil
    end
    
    if warZoneCenterBlip then
        RemoveBlip(warZoneCenterBlip)
        warZoneCenterBlip = nil
    end
    
    if warZoneThread then
        warZoneThread = nil
    end
    
    Config.SuccessPrint('Zone supprimÃ©e')
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- THREAD SURVEILLANCE MORT AVANT COMBAT
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function StartDeathInVehicleMonitor()
    if deathInVehicleThread then return end
    
    Config.InfoPrint('[DEATH] ğŸš¨ Thread surveillance mort prÃ©-combat dÃ©marrÃ©')
    Config.InfoPrint('[DEATH] Mon rÃ´le: ' .. string.upper(myRole or 'INCONNU'))
    
    deathInVehicleThread = CreateThread(function()
        while inGame do
            Wait(500)
            
            local ped = PlayerPedId()
            local shouldMonitor = false
            
            if iAmChasseur and not zoneCreatedByMe then
                shouldMonitor = true
            end
            
            if iAmCible and not iAmInZone then
                shouldMonitor = true
            end
            
            if not shouldMonitor then
                Config.InfoPrint('[DEATH] âœ… Conditions combat remplies, fin surveillance prÃ©-combat')
                break
            end
            
            if IsEntityDead(ped) or GetEntityHealth(ped) <= 0 then
                Config.InfoPrint('[DEATH] ğŸ’€ MORT AVANT COMBAT! RÃ´le: ' .. string.upper(myRole))
                Config.InfoPrint('[DEATH] - Zone crÃ©Ã©e par moi: ' .. tostring(zoneCreatedByMe))
                Config.InfoPrint('[DEATH] - Je suis dans zone: ' .. tostring(iAmInZone))
                
                SendNUIMessage({ action = 'showDeathScreen' })
                Wait(2000)
                
                TriggerServerEvent('scharman:server:playerDied', instanceId)
                
                Config.ErrorPrint('[DEATH] Ã‰vÃ©nement mort envoyÃ© au serveur!')
                break
            end
        end
        
        deathInVehicleThread = nil
        Config.DebugPrint('[DEATH] Thread surveillance prÃ©-combat arrÃªtÃ©')
    end)
end

local function StopDeathInVehicleMonitor()
    if deathInVehicleThread then
        deathInVehicleThread = nil
        Config.InfoPrint('[DEATH] Thread surveillance prÃ©-combat rÃ©initialisÃ©')
    end
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- THREAD BLOCAGE TIRS EN VÃ‰HICULE
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function StartVehicleShootBlockThread()
    if vehicleShootBlockThread then return end
    
    Config.InfoPrint('[VEHICLE] ğŸš« Thread blocage tirs vÃ©hicule dÃ©marrÃ©')
    
    vehicleShootBlockThread = CreateThread(function()
        while inGame do
            Wait(0)
            
            local ped = PlayerPedId()
            
            if IsPedInAnyVehicle(ped, false) then
                DisableControlAction(0, 24, true)
                DisableControlAction(0, 25, true)
                DisableControlAction(0, 69, true)
                DisableControlAction(0, 70, true)
                DisableControlAction(0, 92, true)
                DisableControlAction(0, 114, true)
                DisableControlAction(0, 331, true)
                DisableControlAction(1, 140, true)
                DisableControlAction(1, 141, true)
                DisableControlAction(1, 142, true)
            end
        end
        
        vehicleShootBlockThread = nil
        Config.InfoPrint('[VEHICLE] ğŸš« Thread blocage tirs arrÃªtÃ©')
    end)
end

local function StopVehicleShootBlockThread()
    if vehicleShootBlockThread then
        vehicleShootBlockThread = nil
        Config.InfoPrint('[VEHICLE] ğŸš« Thread blocage tirs rÃ©initialisÃ©')
    end
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- âœ… NOUVEAU V4.0.1: DÃ‰COMPTE SYNCHRONISÃ‰
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function StartSynchronizedCountdown()
    Config.InfoPrint('â±ï¸ DÃ‰COMPTE SYNCHRONISÃ‰ 3-2-1-GO')
    
    local ped = PlayerPedId()
    
    -- Freeze pendant le dÃ©compte
    FreezeEntityPosition(ped, true)
    if currentVehicle and DoesEntityExist(currentVehicle) then
        FreezeEntityPosition(currentVehicle, true)
        SetVehicleEngineOn(currentVehicle, false, true, false)
    end
    
    SendNUIMessage({ action = 'showCountdown', data = { number = 3 } })
    PlaySoundFrontend(-1, 'CHECKPOINT_NORMAL', 'HUD_MINI_GAME_SOUNDSET', true)
    Wait(1000)
    
    SendNUIMessage({ action = 'showCountdown', data = { number = 2 } })
    PlaySoundFrontend(-1, 'CHECKPOINT_NORMAL', 'HUD_MINI_GAME_SOUNDSET', true)
    Wait(1000)
    
    SendNUIMessage({ action = 'showCountdown', data = { number = 1 } })
    PlaySoundFrontend(-1, 'CHECKPOINT_NORMAL', 'HUD_MINI_GAME_SOUNDSET', true)
    Wait(1000)
    
    SendNUIMessage({ action = 'showCountdown', data = { number = 'GO!' } })
    PlaySoundFrontend(-1, 'RACE_PLACED', 'HUD_AWARDS', true)
    Wait(1000)
    
    -- DÃ©freeze aprÃ¨s GO
    FreezeEntityPosition(ped, false)
    if currentVehicle and DoesEntityExist(currentVehicle) then
        FreezeEntityPosition(currentVehicle, false)
        SetVehicleEngineOn(currentVehicle, true, true, false)
    end
    
    SendNUIMessage({ action = 'hideCountdown' })
    
    -- Enregistrer le temps de dÃ©part
    gameStartTime = GetGameTimer()
    
    -- DÃ©marrer les threads de jeu
    StartBlockExitThread()
    StartVehicleExitDetectionThread()
    StartZonePresenceCheckThread()
    StartDeathInVehicleMonitor()
    StartVehicleShootBlockThread()
    
    Config.SuccessPrint('âœ… DÃ©compte terminÃ© - Partie lancÃ©e!')
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- THREAD DÃ‰GÃ‚TS ZONE
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function StartDamageZoneThread()
    if damageZoneThread then return end
    
    Config.InfoPrint('[DAMAGE] ğŸ”´ DÃ©marrage thread dÃ©gÃ¢ts')
    
    damageZoneThread = CreateThread(function()
        while inGame and warZoneActive do
            Wait(Config.CoursePoursuit.DamageInterval)
            
            if not warZonePosition then
                Config.DebugPrint('[DAMAGE] warZonePosition nil, attente...')
                Wait(500)
                goto continue
            end
            
            local ped = PlayerPedId()
            
            if IsEntityDead(ped) or GetEntityHealth(ped) <= 0 then
                Config.InfoPrint('[DAMAGE] ğŸ’€ Joueur mort')
                
                SendNUIMessage({ action = 'showDeathScreen' })
                Wait(3000)
                
                TriggerServerEvent('scharman:server:playerDied', instanceId)
                
                break
            end
            
            local playerCoords = GetEntityCoords(ped)
            local distance = #(playerCoords - vector3(warZonePosition.x, warZonePosition.y, warZonePosition.z))
            
            if distance > warZoneRadius then
                local currentHealth = GetEntityHealth(ped)
                local newHealth = currentHealth - Config.CoursePoursuit.OutOfZoneDamage
                
                Config.InfoPrint(string.format('[DAMAGE] âš¡ HORS ZONE! Distance: %.1fm | HP: %d â†’ %d', distance, currentHealth, newHealth))
                
                if not warningMessageActive then
                    warningMessageActive = true
                    
                    CreateThread(function()
                        while inGame and warZonePosition and distance > warZoneRadius do
                            ShowGameNotification(Config.CoursePoursuit.Notifications.outOfZone, 1500, 'warning')
                            Wait(2000)
                            
                            if not warZonePosition then break end
                            
                            local newCoords = GetEntityCoords(PlayerPedId())
                            distance = #(newCoords - vector3(warZonePosition.x, warZonePosition.y, warZonePosition.z))
                        end
                        
                        warningMessageActive = false
                        if inGame then
                            ShowGameNotification('âœ… Retour dans la zone!', 2000, 'success')
                        end
                    end)
                end
                
                SetEntityHealth(ped, math.max(0, newHealth))
                ShowGameNotification(string.format(Config.CoursePoursuit.Notifications.takingDamage, Config.CoursePoursuit.OutOfZoneDamage), 1500, 'error')
            else
                warningMessageActive = false
            end
            
            ::continue::
        end
        
        damageZoneThread = nil
        Config.InfoPrint('[DAMAGE] ğŸ”´ Thread dÃ©gÃ¢ts arrÃªtÃ©')
    end)
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- THREAD BLOCAGE SORTIE VÃ‰HICULE
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function StartBlockExitThread()
    if blockExitThread then return end
    
    Config.InfoPrint('[BLOCK EXIT] Thread blocage sortie dÃ©marrÃ©')
    
    blockExitTimerThread = CreateThread(function()
        Config.InfoPrint('[BLOCK EXIT] â° Thread timer dÃ©marrÃ© (' .. Config.CoursePoursuit.BlockExitDuration .. 's)')
        
        SendNUIMessage({
            action = 'showVehicleLock',
            data = { duration = Config.CoursePoursuit.BlockExitDuration * 1000 }
        })
        
        Wait(Config.CoursePoursuit.BlockExitDuration * 1000)
        
        if not inGame then
            Config.InfoPrint('[BLOCK EXIT] â° Timer annulÃ© (plus en jeu)')
            blockExitTimerThread = nil
            return
        end
        
        if iAmChasseur then
            canExitVehicle = true
            Config.SuccessPrint('[BLOCK EXIT] âœ… Sortie vÃ©hicule autorisÃ©e (CHASSEUR)!')
            ShowGameNotification(Config.CoursePoursuit.Notifications.canExitVehicle, 5000, 'success')
            
            -- âœ… V4.0: DÃ©marrer le timer chasseur
            StartChasseurTimer()
        else
            Config.InfoPrint('[BLOCK EXIT] â³ CIBLE en attente de la zone...')
            ShowGameNotification(Config.CoursePoursuit.Notifications.mustJoinZone, 5000, 'warning')
        end
        
        SendNUIMessage({ action = 'hideVehicleLock' })
        
        blockExitTimerThread = nil
        Config.DebugPrint('[BLOCK EXIT] â° Thread timer terminÃ©')
    end)
    
    blockExitThread = CreateThread(function()
        Config.DebugPrint('[BLOCK EXIT] ğŸš« Thread contrÃ´le dÃ©marrÃ©')
        
        while inGame and Config.CoursePoursuit.BlockExitVehicle and not canExitVehicle do
            Wait(0)
            
            local ped = PlayerPedId()
            local isInVehicle = IsPedInVehicle(ped, currentVehicle, false)
            
            DisableControlAction(0, 75, true)
            
            if IsDisabledControlJustPressed(0, 75) then
                local timeElapsed = (GetGameTimer() - gameStartTime) / 1000
                local timeLeft = math.max(0, Config.CoursePoursuit.BlockExitDuration - timeElapsed)
                
                if iAmCible and timeLeft <= 0 then
                    ShowGameNotification(Config.CoursePoursuit.Notifications.mustJoinZone, 3000, 'warning')
                else
                    ShowGameNotification(string.format('â° Attendez encore %d secondes!', math.ceil(timeLeft)), 3000, 'warning')
                end
            end
            
            if DoesEntityExist(currentVehicle) and not isInVehicle then
                ForcePlayerIntoVehicle(ped, currentVehicle, -1)
                if iAmCible then
                    ShowGameNotification(Config.CoursePoursuit.Notifications.joinZoneFirst, 3000, 'warning')
                else
                    ShowGameNotification('ğŸš— Retour forcÃ© - Attendez', 3000, 'warning')
                end
            end
        end
        
        blockExitThread = nil
        Config.DebugPrint('[BLOCK EXIT] ğŸš« Thread contrÃ´le arrÃªtÃ© (canExitVehicle = true)')
    end)
end

local function StopBlockExitThread()
    if blockExitThread then
        blockExitThread = nil
        Config.InfoPrint('[BLOCK EXIT] ğŸš« Thread contrÃ´le rÃ©initialisÃ©')
    end
    
    if blockExitTimerThread then
        blockExitTimerThread = nil
        Config.InfoPrint('[BLOCK EXIT] â° Thread timer rÃ©initialisÃ©')
    end
    
    SendNUIMessage({ action = 'hideVehicleLock' })
end

local function StartVehicleExitDetectionThread()
    if not iAmChasseur then
        Config.InfoPrint('[CHASSEUR] Thread dÃ©tection sortie ignorÃ© (je suis CIBLE)')
        return
    end
    
    if vehicleExitThread then return end
    
    vehicleExitThread = CreateThread(function()
        Config.DebugPrint('[CHASSEUR] Thread dÃ©tection sortie dÃ©marrÃ©')
        
        while inGame and not zoneCreatedByMe and iAmChasseur do
            Wait(500)
            
            local ped = PlayerPedId()
            
            if canExitVehicle and not IsPedInAnyVehicle(ped, false) then
                local coords = GetEntityCoords(ped)
                
                if CreateWarZone(coords) then
                    local weaponHash = GetHashKey(Config.CoursePoursuit.WeaponHash)
                    GiveWeaponToPed(ped, weaponHash, Config.CoursePoursuit.WeaponAmmo, false, true)
                    SetCurrentPedWeapon(ped, weaponHash, true)
                    
                    ShowGameNotification(Config.CoursePoursuit.Notifications.weaponGiven, 3000, 'success')
                    ShowGameNotification(Config.CoursePoursuit.Notifications.waitingCible, 5000, 'info')
                    Config.SuccessPrint('[CHASSEUR] Zone crÃ©Ã©e & arme donnÃ©e')
                    
                    StartDamageZoneThread()
                else
                    Config.ErrorPrint('[CHASSEUR] Ã‰chec crÃ©ation zone')
                end
                
                break
            end
        end
        
        vehicleExitThread = nil
        Config.DebugPrint('[CHASSEUR] Thread dÃ©tection sortie arrÃªtÃ©')
    end)
end

local function StartZonePresenceCheckThread()
    if not iAmCible then
        Config.InfoPrint('[CIBLE] Thread prÃ©sence zone ignorÃ© (je suis CHASSEUR)')
        return
    end
    
    if zoneWaitingThread then return end
    
    zoneWaitingThread = CreateThread(function()
        Config.InfoPrint('[CIBLE] Attente zone adverse...')
        
        while inGame and not warZonePosition do
            Wait(500)
        end
        
        if not inGame then
            zoneWaitingThread = nil
            return
        end
        
        Config.InfoPrint('[CIBLE] Zone dÃ©tectÃ©e! VÃ©rification prÃ©sence...')
        
        -- âœ… V4.0: DÃ©marrer le timer cible
        StartCibleTimer()
        
        while inGame and iAmCible and not iAmInZone and warZonePosition do
            Wait(500)
            
            if not warZonePosition then
                Config.DebugPrint('[CIBLE] warZonePosition nil, arrÃªt')
                break
            end
            
            local ped = PlayerPedId()
            local playerCoords = GetEntityCoords(ped)
            local distance = #(playerCoords - vector3(warZonePosition.x, warZonePosition.y, warZonePosition.z))
            
            if distance <= warZoneRadius then
                iAmInZone = true
                canExitVehicle = true
                
                -- âœ… V4.0: ArrÃªter le timer cible
                StopCibleTimer()
                
                Config.SuccessPrint('[CIBLE] âœ… Je suis dans la zone adverse!')
                
                TriggerServerEvent('scharman:server:playerEnteredZone', instanceId)
                
                ShowGameNotification(Config.CoursePoursuit.Notifications.zoneJoined, 5000, 'success')
                
                local weaponHash = GetHashKey(Config.CoursePoursuit.WeaponHash)
                GiveWeaponToPed(ped, weaponHash, Config.CoursePoursuit.WeaponAmmo, false, true)
                SetCurrentPedWeapon(ped, weaponHash, true)
                ShowGameNotification(Config.CoursePoursuit.Notifications.weaponGiven, 3000, 'success')
                Config.SuccessPrint('[CIBLE] Arme donnÃ©e!')
                
                StartDamageZoneThread()
                Config.SuccessPrint('[CIBLE] Thread dÃ©gÃ¢ts dÃ©marrÃ©')
                
                break
            end
        end
        
        zoneWaitingThread = nil
        Config.DebugPrint('[CIBLE] Thread prÃ©sence zone arrÃªtÃ©')
    end)
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- âœ… NOUVEAU V4.0.1: PRÃ‰PARATION JEU (SANS COUNTDOWN)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function PrepareCoursePoursuiteGame(data)
    if inGame then return end
    
    Config.InfoPrint('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•')
    Config.InfoPrint('PRÃ‰PARATION COURSE POURSUITE V4.0.1 - SYNCHRONISATION')
    Config.InfoPrint('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•')
    
    local success, err = pcall(function()
        local ped = PlayerPedId()
        instanceId = data.instanceId
        myRole = data.role
        opponentId = data.opponentId
        
        iAmChasseur = (myRole == 'chasseur')
        iAmCible = (myRole == 'cible')
        
        Config.InfoPrint('Mon rÃ´le: ' .. string.upper(myRole))
        Config.InfoPrint('Adversaire: ' .. opponentId)
        
        local spawnCoords = data.spawnCoords
        
        -- Notification de rÃ´le
        if iAmChasseur then
            ShowGameNotification(Config.CoursePoursuit.Notifications.roleChasseur, 5000, 'info')
        else
            ShowGameNotification(Config.CoursePoursuit.Notifications.roleCible, 5000, 'info')
        end
        
        ShowGameNotification('â³ PrÃ©paration de la partie...', 2000, 'info')
        
        -- Fade out
        DoScreenFadeOut(800)
        while not IsScreenFadedOut() do Wait(10) end
        
        -- TÃ©lÃ©portation
        SetEntityCoords(ped, spawnCoords.x, spawnCoords.y, spawnCoords.z, false, false, false, true)
        SetEntityHeading(ped, spawnCoords.w)
        
        currentBucket = data.bucketId or 0
        
        if currentBucket > 0 then
            Config.InfoPrint('Synchronisation bucket ' .. currentBucket)
            Wait(2000)
            Config.SuccessPrint('Synchro terminÃ©e')
        else
            Wait(1000)
        end
        
        -- Appliquer HP et ARMOR
        SetEntityHealth(ped, Config.CoursePoursuit.PlayerHealth)
        SetPedArmour(ped, Config.CoursePoursuit.PlayerArmor)
        Config.SuccessPrint('HP joueur: ' .. Config.CoursePoursuit.PlayerHealth)
        Config.SuccessPrint('Armor joueur: ' .. Config.CoursePoursuit.PlayerArmor)
        ShowGameNotification(Config.CoursePoursuit.Notifications.armorGiven, 3000, 'success')
        
        Wait(500)
        
        -- RÃ©cupÃ©ration vÃ©hicule
        local vehicleNetId = data.vehicleNetId
        
        if vehicleNetId then
            Config.InfoPrint('â•â•â• RÃ‰CUPÃ‰RATION VÃ‰HICULE â•â•â•')
            
            local maxAttempts = 100
            local attempt = 0
            
            repeat
                currentVehicle = NetworkGetEntityFromNetworkId(vehicleNetId)
                
                if currentVehicle and DoesEntityExist(currentVehicle) then
                    Config.SuccessPrint('VÃ©hicule rÃ©cupÃ©rÃ©: ' .. currentVehicle)
                    break
                end
                
                attempt = attempt + 1
                Wait(100)
            until attempt >= maxAttempts
            
            if not currentVehicle or not DoesEntityExist(currentVehicle) then
                error('Ã‰chec rÃ©cupÃ©ration vÃ©hicule')
            end
            
            SetVehicleOnGroundProperly(currentVehicle)
            Wait(500)
        end
        
        -- Personnalisation vÃ©hicule
        local customKey = iAmChasseur and 'chasseur' or 'cible'
        local customization = Config.CoursePoursuit.VehicleCustomization[customKey]
        
        SetVehicleCustomPrimaryColour(currentVehicle, customization.primaryColor.r, customization.primaryColor.g, customization.primaryColor.b)
        SetVehicleCustomSecondaryColour(currentVehicle, customization.secondaryColor.r, customization.secondaryColor.g, customization.secondaryColor.b)
        SetVehicleNumberPlateText(currentVehicle, customization.plate)
        
        local mods = Config.CoursePoursuit.VehicleCustomization.mods
        SetVehicleMod(currentVehicle, 11, mods.engine, false)
        SetVehicleMod(currentVehicle, 12, mods.brakes, false)
        SetVehicleMod(currentVehicle, 13, mods.transmission, false)
        SetVehicleMod(currentVehicle, 15, mods.suspension, false)
        ToggleVehicleMod(currentVehicle, 18, mods.turbo)
        
        SetVehicleEngineHealth(currentVehicle, 1000.0)
        SetVehicleBodyHealth(currentVehicle, 1000.0)
        SetVehicleDoorsLocked(currentVehicle, 2)
        
        Config.SuccessPrint('VÃ©hicule personnalisÃ©')
        
        -- Placement joueur dans vÃ©hicule
        Config.InfoPrint('â•â•â• PLACEMENT JOUEUR â•â•â•')
        local placementSuccess = ForcePlayerIntoVehicle(ped, currentVehicle, -1)
        
        if not placementSuccess then
            error('Impossible de placer joueur')
        end
        
        -- Fade in
        DoScreenFadeIn(500)
        while not IsScreenFadedIn() do Wait(10) end
        
        -- Marquer comme prÃªt
        inGame = true
        isReadyForStart = true
        
        Config.SuccessPrint('âœ… PRÃ‰PARATION TERMINÃ‰E - EN ATTENTE ADVERSAIRE')
        
        -- âœ… NOUVEAU: Signaler au serveur qu'on est prÃªt
        TriggerServerEvent('scharman:server:playerReady', instanceId)
        
        ShowGameNotification('âœ… PrÃªt! En attente de l\'adversaire...', 3000, 'info')
    end)
    
    if not success then
        Config.ErrorPrint('ERREUR: ' .. tostring(err))
        
        if IsScreenFadedOut() then
            DoScreenFadeIn(500)
        end
        
        if DoesEntityExist(currentVehicle) then
            DeleteEntity(currentVehicle)
            currentVehicle = nil
        end
        
        DeleteWarZone()
        
        ShowGameNotification('âŒ Erreur: ' .. tostring(err), 5000, 'error')
        TriggerServerEvent('scharman:server:coursePoursuiteLeft', instanceId)
        
        inGame = false
        instanceId = nil
        isReadyForStart = false
    end
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ARRÃŠT JEU
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function StopCoursePoursuiteGame(showVictory)
    if not inGame then return end
    
    Config.InfoPrint('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•')
    Config.InfoPrint('ARRÃŠT COURSE POURSUITE V4.0.1')
    Config.InfoPrint('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•')
    
    inGame = false
    isReadyForStart = false
    
    Wait(100)
    
    -- âœ… V4.0: ArrÃªter les timers
    StopChasseurTimer()
    StopCibleTimer()
    
    StopBlockExitThread()
    blockExitThread = nil
    vehicleExitThread = nil
    damageZoneThread = nil
    zoneWaitingThread = nil
    StopVehicleShootBlockThread()
    StopDeathInVehicleMonitor()
    gameEndTime = nil
    gameStartTime = nil
    canExitVehicle = false
    zoneCreatedByMe = false
    zoneCreatedByOpponent = false
    iAmInZone = false
    iAmChasseur = false
    iAmCible = false
    currentBucket = 0
    warningMessageActive = false
    myRole = nil
    opponentId = nil
    
    SendNUIMessage({ action = 'hideDeathScreen' })
    SendNUIMessage({ action = 'hideVehicleLock' })
    SendNUIMessage({ action = 'hideCountdown' })
    SendNUIMessage({ action = 'hideTimer' })
    
    DeleteWarZone()
    
    local ped = PlayerPedId()
    
    RemoveAllPedWeapons(ped, true)
    
    if Config.CoursePoursuit.ReturnToNormalCoords then
        DoScreenFadeOut(500)
        Wait(500)
        
        local returnCoords = Config.CoursePoursuit.ReturnToNormalCoords
        
        if IsEntityDead(ped) or GetEntityHealth(ped) <= 0 then
            NetworkResurrectLocalPlayer(returnCoords.x, returnCoords.y, returnCoords.z, returnCoords.w, true, false)
            Wait(500)
        end
        
        SetEntityHealth(ped, 200)
        SetPedArmour(ped, 0)
        ClearPedTasksImmediately(ped)
        
        SetEntityCoords(ped, returnCoords.x, returnCoords.y, returnCoords.z, false, false, false, true)
        SetEntityHeading(ped, returnCoords.w)
        
        Config.SuccessPrint('TÃ©lÃ©portation retour rÃ©ussie')
        
        Wait(500)
        
        if showVictory ~= nil then
            if showVictory then
                ShowGameNotification(Config.CoursePoursuit.Notifications.youWon, 5000, 'success')
            else
                ShowGameNotification(Config.CoursePoursuit.Notifications.youLost, 5000, 'error')
            end
        end
        
        DoScreenFadeIn(500)
    end
    
    if DoesEntityExist(currentVehicle) then
        DeleteEntity(currentVehicle)
        currentVehicle = nil
    end
    
    instanceId = nil
    
    Config.SuccessPrint('NETTOYAGE TERMINÃ‰')
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- Ã‰VÃ‰NEMENTS RÃ‰SEAU
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- âœ… NOUVEAU V4.0.1: Ã‰vÃ©nement de prÃ©paration (sans countdown)
RegisterNetEvent('scharman:client:prepareCoursePoursuit', function(data)
    PrepareCoursePoursuiteGame(data)
end)

-- âœ… NOUVEAU V4.0.1: Ã‰vÃ©nement de dÃ©marrage synchronisÃ© (avec countdown)
RegisterNetEvent('scharman:client:startSynchronizedGame', function()
    if not isReadyForStart then
        Config.ErrorPrint('ReÃ§u startSynchronizedGame mais pas prÃªt!')
        return
    end
    
    Config.InfoPrint('ğŸš€ DÃ‰MARRAGE SYNCHRONISÃ‰ REÃ‡U!')
    
    if Config.CoursePoursuit.EnableCountdown then
        StartSynchronizedCountdown()
    else
        gameStartTime = GetGameTimer()
        StartBlockExitThread()
        StartVehicleExitDetectionThread()
        StartZonePresenceCheckThread()
        StartDeathInVehicleMonitor()
        StartVehicleShootBlockThread()
    end
end)

RegisterNetEvent('scharman:client:stopCoursePoursuit', function(showVictory)
    StopCoursePoursuiteGame(showVictory)
end)

RegisterNetEvent('scharman:client:courseNotification', function(message, duration, notifType)
    ShowGameNotification(message, duration or 3000, notifType or 'info')
end)

RegisterNetEvent('scharman:client:opponentCreatedZone', function(position)
    if not position then
        Config.ErrorPrint('[CIBLE] Position zone invalide reÃ§ue')
        return
    end
    
    Config.InfoPrint('[CIBLE] âš ï¸ CHASSEUR A CRÃ‰Ã‰ LA ZONE!')
    Config.DebugPrint('[CIBLE] Position: ' .. tostring(position))
    
    warZonePosition = position
    warZoneActive = true
    zoneCreatedByOpponent = true
    
    if not CreateWarZoneVisuals(position) then
        Config.ErrorPrint('[CIBLE] Ã‰chec crÃ©ation visuels zone')
        return
    end
    
    StartWarZoneThread()
    
    ShowGameNotification(Config.CoursePoursuit.Notifications.opponentCreatedZone, 5000, 'warning')
    ShowGameNotification(Config.CoursePoursuit.Notifications.joinZoneFirst, 5000, 'info')
end)

RegisterNetEvent('scharman:client:opponentEnteredZone', function()
    Config.InfoPrint('[CHASSEUR] âœ… CIBLE DANS LA ZONE!')
    
    ShowGameNotification(Config.CoursePoursuit.Notifications.cibleInZone, 5000, 'success')
    
    if not damageZoneThread and warZoneActive then
        StartDamageZoneThread()
    end
end)

RegisterNetEvent('scharman:client:opponentDied', function()
    Config.InfoPrint('ğŸ† ADVERSAIRE MORT - VICTOIRE!')
    
    Wait(2000)
    StopCoursePoursuiteGame(true)
end)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- COMMANDES
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

RegisterCommand('quit_course', function()
    if inGame then
        StopCoursePoursuiteGame()
        TriggerServerEvent('scharman:server:coursePoursuiteLeft', instanceId)
        ShowGameNotification('âœ… Vous avez quittÃ©', 3000, 'success')
    else
        ShowGameNotification('âŒ Vous n\'Ãªtes pas en partie', 3000, 'error')
    end
end, false)

if Config.Debug then
    RegisterCommand('course_info', function()
        print('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•')
        print('Ã‰tat: ' .. (inGame and 'EN JEU' or 'PAS EN JEU'))
        print('PrÃªt: ' .. (isReadyForStart and 'OUI' or 'NON'))
        print('RÃ´le: ' .. (myRole or 'Aucun'))
        print('Instance: ' .. (instanceId or 'Aucune'))
        print('Adversaire: ' .. (opponentId or 'Aucun'))
        print('VÃ©hicule: ' .. (currentVehicle or 'Aucun'))
        print('Bucket: ' .. currentBucket)
        print('Zone active: ' .. (warZoneActive and 'OUI' or 'NON'))
        print('Zone position: ' .. (warZonePosition and tostring(warZonePosition) or 'Aucune'))
        print('Zone crÃ©Ã©e par moi: ' .. (zoneCreatedByMe and 'OUI' or 'NON'))
        print('Zone crÃ©Ã©e par adversaire: ' .. (zoneCreatedByOpponent and 'OUI' or 'NON'))
        print('Je suis dans zone: ' .. (iAmInZone and 'OUI' or 'NON'))
        print('Peut sortir vÃ©hicule: ' .. (canExitVehicle and 'OUI' or 'NON'))
        print('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€')
        print('Timer chasseur actif: ' .. (chasseurTimerActive and 'OUI' or 'NON'))
        print('Timer cible actif: ' .. (cibleTimerActive and 'OUI' or 'NON'))
        print('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•')
    end, false)
end

Config.DebugPrint('client/course_poursuite.lua V4.0.1 - FIX SYNCHRONISATION chargÃ©')

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- Ã‰VÃ‰NEMENTS ROUNDS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

RegisterNetEvent('scharman:client:showRoundVictory', function(data)
    SendNUIMessage({ action = 'showVictoryScreen' })
end)

RegisterNetEvent('scharman:client:showRoundScoreboard', function(data)
    local myScore = data.isPlayerA and data.score.playerA or data.score.playerB
    local opponentScore = data.isPlayerA and data.score.playerB or data.score.playerA
    
    local scoreboardData = {
        round = data.round,
        score = {
            chasseur = myScore,
            cible = opponentScore
        },
        timeUntilNext = data.timeUntilNext
    }
    
    SendNUIMessage({
        action = 'showRoundScoreboard',
        data = scoreboardData
    })
end)

RegisterNetEvent('scharman:client:hideRoundScoreboard', function()
    SendNUIMessage({ action = 'hideRoundScoreboard' })
end)

RegisterNetEvent('scharman:client:showMatchEnd', function(data)
    local myScore = data.isPlayerA and data.finalScore.playerA or data.finalScore.playerB
    local opponentScore = data.isPlayerA and data.finalScore.playerB or data.finalScore.playerA
    
    local matchEndData = {
        winner = data.winner,
        finalScore = {
            chasseur = myScore,
            cible = opponentScore
        }
    }
    
    SendNUIMessage({
        action = 'showMatchEnd',
        data = matchEndData
    })
    
    CreateThread(function()
        Wait(3000)
        SendNUIMessage({ action = 'hideMatchEnd' })
        Config.InfoPrint('[MATCH END] Ã‰cran masquÃ© automatiquement')
    end)
end)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- FIX: ArrÃªt de manche propre avec rÃ©animation
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
RegisterNetEvent('scharman:client:stopRound', function()
    Config.InfoPrint('[ROUND] â•â•â• ARRÃŠT MANCHE â•â•â•')
    
    -- âœ… V4.0: ArrÃªter les timers
    StopChasseurTimer()
    StopCibleTimer()
    
    SendNUIMessage({ action = 'hideDeathScreen' })
    SendNUIMessage({ action = 'hideVictoryScreen' })
    SendNUIMessage({ action = 'hideTimer' })
    
    local ped = PlayerPedId()
    
    if IsEntityDead(ped) or GetEntityHealth(ped) <= 0 then
        local spawnCoords = iAmChasseur and Config.CoursePoursuit.SpawnCoords.chasseur or Config.CoursePoursuit.SpawnCoords.cible
        NetworkResurrectLocalPlayer(spawnCoords.x, spawnCoords.y, spawnCoords.z, spawnCoords.w, true, false)
        Wait(500)
        Config.SuccessPrint('[ROUND] Joueur rÃ©animÃ©!')
    end
    
    RemoveAllPedWeapons(ped, true)
    
    if DoesEntityExist(currentVehicle) then
        DeleteEntity(currentVehicle)
        currentVehicle = nil
    end
    
    DeleteWarZone()
    canExitVehicle = false
    zoneCreatedByMe = false
    zoneCreatedByOpponent = false
    iAmInZone = false
    isReadyForStart = false
    
    StopBlockExitThread()
    StopDeathInVehicleMonitor()
    
    Config.InfoPrint('[ROUND] Manche arrÃªtÃ©e - En attente prochaine manche')
end)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- FIX: DÃ©marrage prochain round avec nouveau vÃ©hicule
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
RegisterNetEvent('scharman:client:startNextRound', function(data)
    Config.InfoPrint('[ROUND] â•â•â• DÃ‰MARRAGE MANCHE ' .. data.round .. ' â•â•â•')
    
    if data.role then
        myRole = data.role
        iAmChasseur = (myRole == 'chasseur')
        iAmCible = (myRole == 'cible')
        Config.InfoPrint('[ROUND] ğŸ”„ Mon NOUVEAU rÃ´le: ' .. string.upper(myRole))
        
        if iAmChasseur then
            Config.InfoPrint('[ROUND] â†’ Je suis maintenant CHASSEUR')
        else
            Config.InfoPrint('[ROUND] â†’ Je suis maintenant CIBLE')
        end
    else
        Config.ErrorPrint('[ROUND] âš ï¸ Aucun rÃ´le reÃ§u du serveur!')
    end
    
    local ped = PlayerPedId()
    
    local spawnCoords = iAmChasseur and Config.CoursePoursuit.SpawnCoords.chasseur or Config.CoursePoursuit.SpawnCoords.cible
    
    DoScreenFadeOut(300)
    Wait(300)
    
    if IsEntityDead(ped) or GetEntityHealth(ped) <= 0 then
        ResurrectPlayerWithAnimation(ped, spawnCoords)
    end
    
    SetEntityCoords(ped, spawnCoords.x, spawnCoords.y, spawnCoords.z, false, false, false, true)
    SetEntityHeading(ped, spawnCoords.w)
    
    -- âœ… V4.0: Appliquer HP et ARMOR
    SetEntityHealth(ped, Config.CoursePoursuit.PlayerHealth)
    SetPedArmour(ped, Config.CoursePoursuit.PlayerArmor)
    ShowGameNotification(Config.CoursePoursuit.Notifications.armorGiven, 3000, 'success')
    
    ClearPedTasksImmediately(ped)
    
    Wait(500)
    
    local myScore = data.isPlayerA and data.score.playerA or data.score.playerB
    local opponentScore = data.isPlayerA and data.score.playerB or data.score.playerA
    
    ShowGameNotification('ğŸ”„ Manche ' .. data.round .. ' - Score: Vous ' .. myScore .. '-' .. opponentScore .. ' Adversaire', 5000, 'info')
    
    Config.InfoPrint('â•â•â• RÃ‰CUPÃ‰RATION NOUVEAU VÃ‰HICULE â•â•â•')
    
    local vehicleNetId = data.vehicleNetId
    if not vehicleNetId then
        Config.ErrorPrint('[ROUND] Pas de vehicleNetId reÃ§u!')
        return
    end
    
    local maxAttempts = 100
    local attempt = 0
    
    repeat
        currentVehicle = NetworkGetEntityFromNetworkId(vehicleNetId)
        
        if currentVehicle and DoesEntityExist(currentVehicle) then
            Config.SuccessPrint('VÃ©hicule rÃ©cupÃ©rÃ©: ' .. currentVehicle)
            break
        end
        
        attempt = attempt + 1
        Wait(100)
    until attempt >= maxAttempts
    
    if not currentVehicle or not DoesEntityExist(currentVehicle) then
        Config.ErrorPrint('[ROUND] Ã‰chec rÃ©cupÃ©ration vÃ©hicule!')
        return
    end
    
    local customKey = iAmChasseur and 'chasseur' or 'cible'
    local customization = Config.CoursePoursuit.VehicleCustomization[customKey]
    
    SetVehicleCustomPrimaryColour(currentVehicle, customization.primaryColor.r, customization.primaryColor.g, customization.primaryColor.b)
    SetVehicleCustomSecondaryColour(currentVehicle, customization.secondaryColor.r, customization.secondaryColor.g, customization.secondaryColor.b)
    SetVehicleNumberPlateText(currentVehicle, customization.plate)
    SetVehicleEngineOn(currentVehicle, true, true, false)
    SetVehicleDirtLevel(currentVehicle, 0.0)
    SetVehicleOnGroundProperly(currentVehicle)
    
    Config.SuccessPrint('VÃ©hicule personnalisÃ©')
    
    Config.InfoPrint('â•â•â• PLACEMENT JOUEUR â•â•â•')
    Wait(500)
    
    ForcePlayerIntoVehicle(ped, currentVehicle, -1)
    
    Wait(1000)
    
    DoScreenFadeIn(300)
    
    isReadyForStart = true
    
    -- âœ… NOUVEAU V4.0.1: Signaler qu'on est prÃªt pour cette manche
    TriggerServerEvent('scharman:server:roundPlayerReady', instanceId, data.round)
    
    ShowGameNotification('âœ… PrÃªt! En attente de l\'adversaire...', 3000, 'info')
end)

-- âœ… NOUVEAU V4.0.1: DÃ©marrage synchronisÃ© de la manche
RegisterNetEvent('scharman:client:startSynchronizedRound', function()
    if not isReadyForStart then
        Config.ErrorPrint('ReÃ§u startSynchronizedRound mais pas prÃªt!')
        return
    end
    
    Config.InfoPrint('ğŸš€ DÃ‰MARRAGE MANCHE SYNCHRONISÃ‰!')
    
    StartSynchronizedCountdown()
end)
